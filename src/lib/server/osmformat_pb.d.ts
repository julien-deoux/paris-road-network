//* Copyright (c) 2010 Scott A. Crosby. <scott@sacrosby.com>
//
//Permission is hereby granted, free of charge, to any person obtaining a copy of
//this software and associated documentation files (the "Software"), to deal in
//the Software without restriction, including without limitation the rights to
//use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
//of the Software, and to permit persons to whom the Software is furnished to do
//so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in all
//copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//SOFTWARE.
//

// @generated by protoc-gen-es v1.10.0
// @generated from file osmformat.proto (package OSMPBF, syntax proto2)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto2 } from "@bufbuild/protobuf";

/**
 * @generated from message OSMPBF.HeaderBlock
 */
export declare class HeaderBlock extends Message<HeaderBlock> {
  /**
   * @generated from field: optional OSMPBF.HeaderBBox bbox = 1;
   */
  bbox?: HeaderBBox;

  /**
   * Additional tags to aid in parsing this dataset 
   *
   * @generated from field: repeated string required_features = 4;
   */
  requiredFeatures: string[];

  /**
   * @generated from field: repeated string optional_features = 5;
   */
  optionalFeatures: string[];

  /**
   * @generated from field: optional string writingprogram = 16;
   */
  writingprogram?: string;

  /**
   * From the bbox field.
   *
   * @generated from field: optional string source = 17;
   */
  source?: string;

  /**
   * Replication timestamp, expressed in seconds since the epoch,
   * otherwise the same value as in the "timestamp=..." field
   * in the state.txt file used by Osmosis.
   *
   * @generated from field: optional int64 osmosis_replication_timestamp = 32;
   */
  osmosisReplicationTimestamp?: bigint;

  /**
   * Replication sequence number (sequenceNumber in state.txt).
   *
   * @generated from field: optional int64 osmosis_replication_sequence_number = 33;
   */
  osmosisReplicationSequenceNumber?: bigint;

  /**
   * Replication base URL (from Osmosis' configuration.txt file).
   *
   * @generated from field: optional string osmosis_replication_base_url = 34;
   */
  osmosisReplicationBaseUrl?: string;

  constructor(data?: PartialMessage<HeaderBlock>);

  static readonly runtime: typeof proto2;
  static readonly typeName = "OSMPBF.HeaderBlock";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HeaderBlock;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HeaderBlock;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HeaderBlock;

  static equals(a: HeaderBlock | PlainMessage<HeaderBlock> | undefined, b: HeaderBlock | PlainMessage<HeaderBlock> | undefined): boolean;
}

/**
 * @generated from message OSMPBF.HeaderBBox
 */
export declare class HeaderBBox extends Message<HeaderBBox> {
  /**
   * @generated from field: required sint64 left = 1;
   */
  left?: bigint;

  /**
   * @generated from field: required sint64 right = 2;
   */
  right?: bigint;

  /**
   * @generated from field: required sint64 top = 3;
   */
  top?: bigint;

  /**
   * @generated from field: required sint64 bottom = 4;
   */
  bottom?: bigint;

  constructor(data?: PartialMessage<HeaderBBox>);

  static readonly runtime: typeof proto2;
  static readonly typeName = "OSMPBF.HeaderBBox";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): HeaderBBox;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): HeaderBBox;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): HeaderBBox;

  static equals(a: HeaderBBox | PlainMessage<HeaderBBox> | undefined, b: HeaderBBox | PlainMessage<HeaderBBox> | undefined): boolean;
}

/**
 * @generated from message OSMPBF.PrimitiveBlock
 */
export declare class PrimitiveBlock extends Message<PrimitiveBlock> {
  /**
   * @generated from field: required OSMPBF.StringTable stringtable = 1;
   */
  stringtable?: StringTable;

  /**
   * @generated from field: repeated OSMPBF.PrimitiveGroup primitivegroup = 2;
   */
  primitivegroup: PrimitiveGroup[];

  /**
   * Granularity, units of nanodegrees, used to store coordinates in this block.
   *
   * @generated from field: optional int32 granularity = 17 [default = 100];
   */
  granularity?: number;

  /**
   * Offset value between the output coordinates and the granularity grid in units of nanodegrees.
   *
   * @generated from field: optional int64 lat_offset = 19 [default = 0];
   */
  latOffset?: bigint;

  /**
   * @generated from field: optional int64 lon_offset = 20 [default = 0];
   */
  lonOffset?: bigint;

  /**
   * Granularity of dates, normally represented in units of milliseconds since the 1970 epoch.
   *
   * @generated from field: optional int32 date_granularity = 18 [default = 1000];
   */
  dateGranularity?: number;

  constructor(data?: PartialMessage<PrimitiveBlock>);

  static readonly runtime: typeof proto2;
  static readonly typeName = "OSMPBF.PrimitiveBlock";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PrimitiveBlock;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PrimitiveBlock;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PrimitiveBlock;

  static equals(a: PrimitiveBlock | PlainMessage<PrimitiveBlock> | undefined, b: PrimitiveBlock | PlainMessage<PrimitiveBlock> | undefined): boolean;
}

/**
 * Group of OSMPrimitives. All primitives in a group must be the same type.
 *
 * @generated from message OSMPBF.PrimitiveGroup
 */
export declare class PrimitiveGroup extends Message<PrimitiveGroup> {
  /**
   * @generated from field: repeated OSMPBF.Node nodes = 1;
   */
  nodes: Node[];

  /**
   * @generated from field: optional OSMPBF.DenseNodes dense = 2;
   */
  dense?: DenseNodes;

  /**
   * @generated from field: repeated OSMPBF.Way ways = 3;
   */
  ways: Way[];

  /**
   * @generated from field: repeated OSMPBF.Relation relations = 4;
   */
  relations: Relation[];

  /**
   * @generated from field: repeated OSMPBF.ChangeSet changesets = 5;
   */
  changesets: ChangeSet[];

  constructor(data?: PartialMessage<PrimitiveGroup>);

  static readonly runtime: typeof proto2;
  static readonly typeName = "OSMPBF.PrimitiveGroup";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PrimitiveGroup;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PrimitiveGroup;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PrimitiveGroup;

  static equals(a: PrimitiveGroup | PlainMessage<PrimitiveGroup> | undefined, b: PrimitiveGroup | PlainMessage<PrimitiveGroup> | undefined): boolean;
}

/**
 * * String table, contains the common strings in each block.
 *
 * Note that we reserve index '0' as a delimiter, so the entry at that
 * index in the table is ALWAYS blank and unused.
 *
 *
 * @generated from message OSMPBF.StringTable
 */
export declare class StringTable extends Message<StringTable> {
  /**
   * @generated from field: repeated bytes s = 1;
   */
  s: Uint8Array[];

  constructor(data?: PartialMessage<StringTable>);

  static readonly runtime: typeof proto2;
  static readonly typeName = "OSMPBF.StringTable";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StringTable;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StringTable;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StringTable;

  static equals(a: StringTable | PlainMessage<StringTable> | undefined, b: StringTable | PlainMessage<StringTable> | undefined): boolean;
}

/**
 * Optional metadata that may be included into each primitive. 
 *
 * @generated from message OSMPBF.Info
 */
export declare class Info extends Message<Info> {
  /**
   * @generated from field: optional int32 version = 1 [default = -1];
   */
  version?: number;

  /**
   * @generated from field: optional int64 timestamp = 2;
   */
  timestamp?: bigint;

  /**
   * @generated from field: optional int64 changeset = 3;
   */
  changeset?: bigint;

  /**
   * @generated from field: optional int32 uid = 4;
   */
  uid?: number;

  /**
   * String IDs
   *
   * @generated from field: optional uint32 user_sid = 5;
   */
  userSid?: number;

  /**
   * The visible flag is used to store history information. It indicates that
   * the current object version has been created by a delete operation on the
   * OSM API.
   * When a writer sets this flag, it MUST add a required_features tag with
   * value "HistoricalInformation" to the HeaderBlock.
   * If this flag is not available for some object it MUST be assumed to be
   * true if the file has the required_features tag "HistoricalInformation"
   * set.
   *
   * @generated from field: optional bool visible = 6;
   */
  visible?: boolean;

  constructor(data?: PartialMessage<Info>);

  static readonly runtime: typeof proto2;
  static readonly typeName = "OSMPBF.Info";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Info;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Info;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Info;

  static equals(a: Info | PlainMessage<Info> | undefined, b: Info | PlainMessage<Info> | undefined): boolean;
}

/**
 * * Optional metadata that may be included into each primitive. Special dense format used in DenseNodes. 
 *
 * @generated from message OSMPBF.DenseInfo
 */
export declare class DenseInfo extends Message<DenseInfo> {
  /**
   * @generated from field: repeated int32 version = 1 [packed = true];
   */
  version: number[];

  /**
   * DELTA coded
   *
   * @generated from field: repeated sint64 timestamp = 2 [packed = true];
   */
  timestamp: bigint[];

  /**
   * DELTA coded
   *
   * @generated from field: repeated sint64 changeset = 3 [packed = true];
   */
  changeset: bigint[];

  /**
   * DELTA coded
   *
   * @generated from field: repeated sint32 uid = 4 [packed = true];
   */
  uid: number[];

  /**
   * String IDs for usernames. DELTA coded
   *
   * @generated from field: repeated sint32 user_sid = 5 [packed = true];
   */
  userSid: number[];

  /**
   * The visible flag is used to store history information. It indicates that
   * the current object version has been created by a delete operation on the
   * OSM API.
   * When a writer sets this flag, it MUST add a required_features tag with
   * value "HistoricalInformation" to the HeaderBlock.
   * If this flag is not available for some object it MUST be assumed to be
   * true if the file has the required_features tag "HistoricalInformation"
   * set.
   *
   * @generated from field: repeated bool visible = 6 [packed = true];
   */
  visible: boolean[];

  constructor(data?: PartialMessage<DenseInfo>);

  static readonly runtime: typeof proto2;
  static readonly typeName = "OSMPBF.DenseInfo";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DenseInfo;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DenseInfo;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DenseInfo;

  static equals(a: DenseInfo | PlainMessage<DenseInfo> | undefined, b: DenseInfo | PlainMessage<DenseInfo> | undefined): boolean;
}

/**
 * This is kept for backwards compatibility but not used anywhere.
 *
 * @generated from message OSMPBF.ChangeSet
 */
export declare class ChangeSet extends Message<ChangeSet> {
  /**
   * @generated from field: required int64 id = 1;
   */
  id?: bigint;

  constructor(data?: PartialMessage<ChangeSet>);

  static readonly runtime: typeof proto2;
  static readonly typeName = "OSMPBF.ChangeSet";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChangeSet;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChangeSet;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChangeSet;

  static equals(a: ChangeSet | PlainMessage<ChangeSet> | undefined, b: ChangeSet | PlainMessage<ChangeSet> | undefined): boolean;
}

/**
 * @generated from message OSMPBF.Node
 */
export declare class Node extends Message<Node> {
  /**
   * @generated from field: required sint64 id = 1;
   */
  id?: bigint;

  /**
   * Parallel arrays.
   *
   * String IDs.
   *
   * @generated from field: repeated uint32 keys = 2 [packed = true];
   */
  keys: number[];

  /**
   * String IDs.
   *
   * @generated from field: repeated uint32 vals = 3 [packed = true];
   */
  vals: number[];

  /**
   * May be omitted in omitmeta
   *
   * @generated from field: optional OSMPBF.Info info = 4;
   */
  info?: Info;

  /**
   * @generated from field: required sint64 lat = 8;
   */
  lat?: bigint;

  /**
   * @generated from field: required sint64 lon = 9;
   */
  lon?: bigint;

  constructor(data?: PartialMessage<Node>);

  static readonly runtime: typeof proto2;
  static readonly typeName = "OSMPBF.Node";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Node;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Node;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Node;

  static equals(a: Node | PlainMessage<Node> | undefined, b: Node | PlainMessage<Node> | undefined): boolean;
}

/**
 * @generated from message OSMPBF.DenseNodes
 */
export declare class DenseNodes extends Message<DenseNodes> {
  /**
   * DELTA coded
   *
   * @generated from field: repeated sint64 id = 1 [packed = true];
   */
  id: bigint[];

  /**
   * @generated from field: optional OSMPBF.DenseInfo denseinfo = 5;
   */
  denseinfo?: DenseInfo;

  /**
   * DELTA coded
   *
   * @generated from field: repeated sint64 lat = 8 [packed = true];
   */
  lat: bigint[];

  /**
   * DELTA coded
   *
   * @generated from field: repeated sint64 lon = 9 [packed = true];
   */
  lon: bigint[];

  /**
   * Special packing of keys and vals into one array. May be empty if all nodes in this block are tagless.
   *
   * @generated from field: repeated int32 keys_vals = 10 [packed = true];
   */
  keysVals: number[];

  constructor(data?: PartialMessage<DenseNodes>);

  static readonly runtime: typeof proto2;
  static readonly typeName = "OSMPBF.DenseNodes";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DenseNodes;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DenseNodes;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DenseNodes;

  static equals(a: DenseNodes | PlainMessage<DenseNodes> | undefined, b: DenseNodes | PlainMessage<DenseNodes> | undefined): boolean;
}

/**
 * @generated from message OSMPBF.Way
 */
export declare class Way extends Message<Way> {
  /**
   * @generated from field: required int64 id = 1;
   */
  id?: bigint;

  /**
   * Parallel arrays.
   *
   * @generated from field: repeated uint32 keys = 2 [packed = true];
   */
  keys: number[];

  /**
   * @generated from field: repeated uint32 vals = 3 [packed = true];
   */
  vals: number[];

  /**
   * @generated from field: optional OSMPBF.Info info = 4;
   */
  info?: Info;

  /**
   * DELTA coded
   *
   * @generated from field: repeated sint64 refs = 8 [packed = true];
   */
  refs: bigint[];

  /**
   * The following two fields are optional. They are only used in a special
   * format where node locations are also added to the ways. This makes the
   * files larger, but allows creating way geometries directly.
   *
   * If this is used, you MUST set the optional_features tag "LocationsOnWays"
   * and the number of values in refs, lat, and lon MUST be the same.
   *
   * DELTA coded, optional
   *
   * @generated from field: repeated sint64 lat = 9 [packed = true];
   */
  lat: bigint[];

  /**
   * DELTA coded, optional
   *
   * @generated from field: repeated sint64 lon = 10 [packed = true];
   */
  lon: bigint[];

  constructor(data?: PartialMessage<Way>);

  static readonly runtime: typeof proto2;
  static readonly typeName = "OSMPBF.Way";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Way;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Way;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Way;

  static equals(a: Way | PlainMessage<Way> | undefined, b: Way | PlainMessage<Way> | undefined): boolean;
}

/**
 * @generated from message OSMPBF.Relation
 */
export declare class Relation extends Message<Relation> {
  /**
   * @generated from field: required int64 id = 1;
   */
  id?: bigint;

  /**
   * Parallel arrays.
   *
   * @generated from field: repeated uint32 keys = 2 [packed = true];
   */
  keys: number[];

  /**
   * @generated from field: repeated uint32 vals = 3 [packed = true];
   */
  vals: number[];

  /**
   * @generated from field: optional OSMPBF.Info info = 4;
   */
  info?: Info;

  /**
   * Parallel arrays
   *
   * This should have been defined as uint32 for consistency, but it is now too late to change it
   *
   * @generated from field: repeated int32 roles_sid = 8 [packed = true];
   */
  rolesSid: number[];

  /**
   * DELTA encoded
   *
   * @generated from field: repeated sint64 memids = 9 [packed = true];
   */
  memids: bigint[];

  /**
   * @generated from field: repeated OSMPBF.Relation.MemberType types = 10 [packed = true];
   */
  types: Relation_MemberType[];

  constructor(data?: PartialMessage<Relation>);

  static readonly runtime: typeof proto2;
  static readonly typeName = "OSMPBF.Relation";
  static readonly fields: FieldList;

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Relation;

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Relation;

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Relation;

  static equals(a: Relation | PlainMessage<Relation> | undefined, b: Relation | PlainMessage<Relation> | undefined): boolean;
}

/**
 * @generated from enum OSMPBF.Relation.MemberType
 */
export declare enum Relation_MemberType {
  /**
   * @generated from enum value: NODE = 0;
   */
  NODE = 0,

  /**
   * @generated from enum value: WAY = 1;
   */
  WAY = 1,

  /**
   * @generated from enum value: RELATION = 2;
   */
  RELATION = 2,
}

